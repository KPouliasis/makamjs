(* Manually converted from ocaml-4.02.1/parsing/ast_helper
   
   For the time being, only expressions, patterns and types are converted.
   Modules and module signatures are still todo.
   
   Names of constants are important: they need to correspond to
   the original functions or constructors *)

%use utils.
%import "examples/newparsing/miniexp" as miniexp.

(* Base types from asttypes *)
lid, str : type.
lid : string -> lid.
str : string -> str.

constant : type.
const_int : int -> constant.
const_char : string -> constant.
const_string : string -> option string -> constant.

rec_flag, direction_flag, private_flag, mutable_flag, virtual_flag, override_flag, closed_flag : type.
nonrecursive, recursive : rec_flag.
upto, downto : direction_flag.
private, public : private_flag.
mutable, immutable : private_flag.
virtual, concrete : virtual_flag.
override, fresh : override_flag.
closed, open : closed_flag.


(* Type expressions *)
core_type : type.
any: unit -> core_type.
var: string -> core_type.
arrow: string -> core_type -> core_type -> core_type.
tuple: list core_type -> core_type.
constr: lid -> list core_type -> core_type.
class_: lid -> list core_type -> core_type.
alias: core_type -> string -> core_type.
poly: list string -> core_type -> core_type.
package: lid -> list (tuple lid core_type) -> core_type.
force_poly: core_type -> core_type.


(* Patterns *)
pattern : type.
any: unit -> pattern.
var: str -> pattern.
alias: pattern -> str -> pattern.
constant: constant -> pattern.
interval: constant -> constant -> pattern.
tuple: list pattern -> pattern.
construct: lid -> option pattern -> pattern.
variant: string -> option pattern -> pattern.
record: list (tuple lid pattern) -> closed_flag -> pattern.
array: list pattern -> pattern.
or_: pattern -> pattern -> pattern.
lazy_: pattern -> pattern.
unpack: str -> pattern.
exception_: pattern -> pattern.


(* Expressions *)
expression, case, value_binding : type.
ident: lid -> expression.
constant: constant -> expression.
let_: rec_flag -> list value_binding -> expression -> expression.
fun_: string -> option expression -> pattern -> expression -> expression.
function_: list case -> expression.
apply: expression -> list (tuple string expression) -> expression.
match_: expression -> list case -> expression.
try_: expression -> list case -> expression.
tuple: list expression -> expression.
construct: lid -> option expression -> expression.
variant: string -> option expression -> expression.
record: list (tuple lid expression) -> option expression -> expression.
field: expression -> lid -> expression.
setfield: expression -> lid -> expression -> expression.
array: list expression -> expression.
ifthenelse: expression -> expression -> option expression -> expression.
sequence: expression -> expression -> expression.
while_: expression -> expression -> expression.
for_: pattern -> expression -> expression -> direction_flag -> expression -> expression.
coerce: expression -> option core_type -> core_type -> expression.
constraint_: expression -> core_type -> expression.
send: expression -> string -> expression.
new_: lid -> expression.
setinstvar: str -> expression -> expression.
override: list (tuple str expression) -> expression.
assert_: expression -> expression.
lazy_: expression -> expression.
poly: expression -> option core_type -> expression.
newtype: string -> expression -> expression.
open_: override_flag -> lid -> expression -> expression.
mk : pattern -> expression -> value_binding.
case: pattern -> expression -> case.


(* Actual conversion *)

to_miniexp : dyn -> miniexp.miniexp -> prop.

to_miniexp (dyn (lid L)) (miniexp.record [ ("loc", miniexp.deref (miniexp.var "default_loc")),
                                           ("txt", miniexp.apply "Longident.parse" [ miniexp.str L ]) ]).

to_miniexp (dyn (str S)) (miniexp.record [ ("loc", miniexp.deref (miniexp.var "default_loc")),
                                           ("txt", miniexp.str S )]).

to_miniexp (dyn (S : string)) (miniexp.str S).

to_miniexp (dyn ((some X) : option A))
           (miniexp.constr "Some" [ X' ]) <-
  to_miniexp (dyn X) X'.

to_miniexp (dyn ((none) : option A))
           (miniexp.constr "None" []).

to_miniexp (dyn ((cons HD TL) : list A ))
           (miniexp.cons HD' TL') <-
  to_miniexp (dyn HD) HD',
  to_miniexp (dyn TL) TL'.

to_miniexp (dyn (nil : list A)) (miniexp.nil).

to_miniexp (dyn (tuple A B)) (miniexp.tuple [A', B']) <-
  to_miniexp (dyn A) A',
  to_miniexp (dyn B) B'.

to_miniexp_aux_function : string -> dyn -> miniexp.miniexp -> prop.
to_miniexp_aux_function Prefix (dyn X) (miniexp.apply F Args') <-
  refl.headargs X HD Args,
  refl.headname HD HDName,
  appendmany [ Prefix, ".", HDName ] F,
  map to_miniexp Args Args'.

to_miniexp_aux_constructor : dyn -> miniexp.miniexp -> prop.
to_miniexp_aux_constructor (dyn X) (miniexp.constr F Args') <-
  refl.headargs X HD Args,
  refl.headname HD HDName,
  string.capitalize HDName F,
  map to_miniexp Args Args'.

to_miniexp (dyn (C : constant)) Res <- to_miniexp_aux_constructor (dyn C) Res.

to_miniexp (dyn (F : rec_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.
to_miniexp (dyn (F : direction_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.
to_miniexp (dyn (F : private_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.
to_miniexp (dyn (F : mutable_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.
to_miniexp (dyn (F : override_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.
to_miniexp (dyn (F : closed_flag)) Res <- to_miniexp_aux_constructor (dyn F) Res.

to_miniexp (dyn (T : core_type)) Res <- to_miniexp_aux_function "Typ" (dyn T) Res.

to_miniexp (dyn (E : expression)) Res <- to_miniexp_aux_function "Exp" (dyn E) Res.

to_miniexp (dyn (P : expression)) Res <- to_miniexp_aux_function "Pat" (dyn P) Res.

to_miniexp (dyn (C : case)) Res <- to_miniexp_aux_function "Exp" (dyn C) Res.

to_miniexp (dyn (V : value_binding)) Res <- to_miniexp_aux_function "Vb" (dyn V) Res.



%extend unsafe.
eval_ast : expression -> prop.
eval_ast E <-
  to_miniexp (dyn E) E',
  miniexp.to_ocaml_string E' S,
  appendmany [ """
    open Ast_helper;;
    open Asttypes;;
    let exp = """, S, """;;
    let s = (Pprintast.string_of_expression exp) ^ "\\n" ;;
    !(Termlangprolog.meta_do) s ;;
  """ ] OCamlCode,
  unsafe.eval_ocaml OCamlCode.
%end.

  



unsafe.eval_ast (apply (ident (lid "print_string")) [ tuple "" (constant (const_string "hello" none)) ]) ?
