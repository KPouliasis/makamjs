(* Manually converted from ocaml-4.02.1/parsing/ast_helper *)
(* Names of constants are important: they need to correspond to
   the original functions *)

%use utils.
%import "examples/newparsing/miniexp" as miniexp.

lid : type.
str : type.

lid : string -> lid.
str : string -> str.

constant : type.
const_int : int -> constant.
const_char : string -> constant.
const_string : string -> option string -> constant.

rec_flag : type.
nonrecursive, recursive : rec_flag.

direction_flag : type.
upto, downto : direction_flag.

private_flag : type.
private, public : private_flag.

mutable_flag : type.
mutable, immutable : private_flag.

virtual_flag : type.
virtual, concerete : virtual_flag.

override_flag : type.
override, fresh : override_flag.

closed_flag : type.
closed, open : closed_flag.

core_type : type.
any: unit -> core_type.
var: string -> core_type.
arrow: string -> core_type -> core_type -> core_type.
tuple: list core_type -> core_type.
constr: lid -> list core_type -> core_type.
class_: lid -> list core_type -> core_type.
alias: core_type -> string -> core_type.
poly: list string -> core_type -> core_type.
package: lid -> list (tuple lid core_type) -> core_type.
force_poly: core_type -> core_type.


pattern : type.

any: unit -> pattern.
var: str -> pattern.
alias: pattern -> str -> pattern.
constant: constant -> pattern.
interval: constant -> constant -> pattern.
tuple: list pattern -> pattern.
construct: lid -> option pattern -> pattern.
variant: string -> option pattern -> pattern.
record: list (tuple lid pattern) -> closed_flag -> pattern.
array: list pattern -> pattern.
or_: pattern -> pattern -> pattern.
lazy_: pattern -> pattern.
unpack: str -> pattern.
exception_: pattern -> pattern.

expression : type.
case : type.

value_binding : type.

mk : pattern -> expression -> value_binding.

ident: lid -> expression.
constant: constant -> expression.
let_: rec_flag -> list value_binding -> expression -> expression.
fun_: string -> option expression -> pattern -> expression -> expression.
function_: list case -> expression.
apply: expression -> list (tuple string expression) -> expression.
match_: expression -> list case -> expression.
try_: expression -> list case -> expression.
tuple: list expression -> expression.
construct: lid -> option expression -> expression.
variant: string -> option expression -> expression.
record: list (tuple lid expression) -> option expression -> expression.
field: expression -> lid -> expression.
setfield: expression -> lid -> expression -> expression.
array: list expression -> expression.
ifthenelse: expression -> expression -> option expression -> expression.
sequence: expression -> expression -> expression.
while_: expression -> expression -> expression.
for_: pattern -> expression -> expression -> direction_flag -> expression -> expression.
coerce: expression -> option core_type -> core_type -> expression.
constraint_: expression -> core_type -> expression.
send: expression -> string -> expression.
new_: lid -> expression.
setinstvar: str -> expression -> expression.
override: list (tuple str expression) -> expression.
assert_: expression -> expression.
lazy_: expression -> expression.
poly: expression -> option core_type -> expression.
newtype: string -> expression -> expression.
open_: override_flag -> lid -> expression -> expression.
case: pattern -> expression -> case.



(* Actual conversion *)

to_miniexp : dyn -> miniexp.miniexp -> prop.

to_miniexp (dyn (lid L)) (miniexp.record [ ("loc", miniexp.deref (miniexp.var "default_loc")),
	                                   ("txt", miniexp.apply "Longident.parse" [ miniexp.str L ]) ]).

to_miniexp (dyn (str S)) (miniexp.record [ ("loc", miniexp.deref (miniexp.var "default_loc")),
	                                   ("txt", miniexp.str S )]).

to_miniexp (dyn (S : string)) (miniexp.str S).

to_miniexp (dyn ( (some X) : option A))
	   (miniexp.constr "Some" [ X' ]) <-
  to_miniexp (dyn X) X'.

to_miniexp (dyn ( (none) : option A))
	   (miniexp.constr "None" []).

to_miniexp (dyn ( (cons HD TL) : list A ))
	   (miniexp.cons HD' TL') <-
  to_miniexp (dyn HD) HD',
  to_miniexp (dyn TL) TL'.

to_miniexp (dyn (nil : list A)) (miniexp.nil).

to_miniexp (dyn (tuple A B)) (miniexp.tuple [A', B']) <-
  to_miniexp (dyn A) A',
  to_miniexp (dyn B) B'.

to_miniexp_aux_function : string -> dyn -> miniexp.miniexp -> prop.
to_miniexp_aux_function Prefix (dyn X) (miniexp.apply F Args') <-
  headargs X HD Args,
  headname HD HDName,
  appendmany [ Prefix, ".", HDName ] F,
  map to_miniexp Args Args'.

to_miniexp_aux_constructor : dyn -> miniexp.miniexp -> prop.
to_miniexp_aux_constructor (dyn X) (miniexp.constr F Args') <-
  headargs X HD Args,
  headname HD HDName,
  (* capitalize HDName F, *)
  eq HDName F,
  map to_miniexp Args Args'.

to_miniexp (dyn ((const_string S OS) : constant)) (miniexp.constr "Const_string" [ miniexp.str S, OS' ]) <-
  to_miniexp (dyn OS) OS'.
to_miniexp (dyn (E : expression)) Res <- to_miniexp_aux_function "Exp" (dyn E) Res.



%extend unsafe.
eval_ast : expression -> prop.
eval_ast E <-
  to_miniexp (dyn E) E',
  miniexp.to_ocaml_string E' S,
  appendmany [ """
    open Ast_helper;;
    open Asttypes;;
    let exp = """, S, """;;
    let s = (Pprintast.string_of_expression exp) ^ "\\n" ;;
    Printf.printf "REAL OCAML CODE:\n\n%s\n" s ;
    !(Termlangprolog.meta_do) s ;;
  """ ] OCamlCode,
  print_string "\nOCAML CODE:\n\n",
  print_string OCamlCode,
  unsafe.eval_ocaml OCamlCode.
%end.

  



unsafe.eval_ast (apply (ident (lid "print_string")) [ tuple "" (constant (const_string "hello" none)) ]) ?