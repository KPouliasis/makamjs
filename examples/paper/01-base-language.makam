(* We will start with encoding a version of System F in 位Prolog. We define two new meta-types to
   represent the two sorts of our object language: terms and types. We also define the `typof`
   relation that corresponds to the typing judgement of the language. *)

term   : type.
typ    : type.
typeof : term -> typ -> prop.

(* Defining the basic forms of the 位-calculus is very easy, thanks to the support of higher-order
   abstract syntax in higher-order logic programming. We can reuse the meta-level function type in
   order to implement object-level binding. This is because the meta-level function space is /parametric/ --
   that is, the body of a function is a value that can just mention the argument as is, instead of being
   a computation that can inspect the specific value of an argument. Therefore, meta-level functions exactly
   represent an object-level binding of a single variable, without introducing /exotic terms/. 
*)

app    : term -> term -> term.
lambda : typ -> (term -> term) -> term.

arrow  : typ -> typ -> typ.

(* Encoding the typing rule for application as a 位Prolog /clause/ for the `typeof` relation is a straightforward
   transliteration of the pen-and-paper version: *)

typeof (app E1 E2) T' :-
  typeof E1 (arrow T T'),
  typeof E2 T.

(* In logic programming, the goal of a rule is written first, followed by the premises; the `:-` operator
   can be read as "is implied by", and `,` is logical conjuction. We use capital letters for unification
   variables. *)

(* The rule for lambda functions is similarly straightforward: *)

typeof (lam T E) (arrow T T') :-
  (x:term -> typeof x T -> typeof (E x) T').

(* There are three things of note in the premise of the rule. First, we introduce a fresh term
   variable `x`, through the form `x:term ->`, which can be read as universal
   quantification. Second, we introduce a new assumption through the form `typeof x T ->`, which
   essentially introduces a new rule for the `typeof` relation locally; this can be read as logical
   implication. Third, in order to get to the body of the lambda function to type-check it, we need to apply the
   fresh variable `x` to it. *)

(* With these definitions, we have already implemented a type-checker for the simply-typed lambda calculus,
   as we can issue queries for the `typeof` relation to Makam: *)

typeof (lam T (fun x => x)) T' ?

(* 
>> T' := arrow T T
*)

(* One benefit of using 位Prolog instead of rolling our own type-checker is that the occurs-check is already
   implemented in the unification engine. As a result, a query that would result in a ill-formed cyclical
   type with a naive implementation of unification, fails as expected.
*)

typeof (lam T (fun x => app x x)) T' ?

(*
>> Impossible.
*)
