%use utils.

%extend refl.

(* nice reflective predicates *)

builtin_isunif : A -> prop.
builtin_isunif X <- isunif X.

isunif : A -> prop.
isunif X <- builtin_isunif X.

isconst : A -> prop.
isconst (X : string).
isconst (X : int).

isfun : A -> prop.
isfun (X : A -> B).

isterm : A -> prop.
(isterm X) when not(isconst X), not(isfun X), headargs X _ _.

%end.

%extend type.

result : A -> B -> prop.
(result X Y) when refl.isfun X <- (x:A -> result (X x) Y).
(result X Y) when not(refl.isfun X) <- typeq X Y.

ispred : A -> prop.
ispred X <- result X (Z : prop).

%end.


dup_head : A -> B -> prop.
(dup_head P P') when refl.isfun P <- (x:T -> dup_head (P x) P').
(dup_head P P') when refl.isterm P <- headargs P Head _, headname P PName, lookup PName P'.

dyncall : (A -> prop) -> dyn -> prop.
dyncall P (dyn X) <- dup_head P P', P' X.

dyncall : (A -> B -> prop) -> dyn -> dyn -> prop.
dyncall P (dyn X) (dyn Y) <- dup_head P P', P' X Y.

([X]allheads X, map0 (dyncall printhead) X) ?


filter : (A -> prop) -> list A -> list A -> prop.
filter P (HD :: TL) (HD :: TL') <- P HD, filter P TL TL'.
filter P (HD :: TL) TL' <- not(P HD), filter P TL TL'.
filter P nil nil.

allrules : list clause -> prop.
allrules Rules <- allheads XS, filter (dyncall type.ispred) XS PS, map (dyncall getrules) PS RulesCD,
                  map (fun x y => eq x (dyn y)) RulesCD RulesC,
                  foldl append [] RulesC Rules.
