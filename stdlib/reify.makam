reified : type -> type.

args : type -> type -> type.
nil : args A A.
cons : A -> args B C -> args (A -> B) C.

%extend dyn.
to_args : [A B] list dyn -> args A B -> prop.
to_args [] [].
to_args (dyn HD :: TL) (HD :: TL') :- to_args TL TL'.

from_args : [A B] args A B -> list dyn -> prop.
from_args [] [].
from_args (HD :: TL) (dyn HD :: TL') :- from_args TL TL'.
%end.

reified_args : type -> type -> type.
nil : reified_args A A.
cons : reified A -> reified_args B C -> reified_args (A -> B) C.

%extend reified.

unifvar : int -> reified_args A B -> B -> reified B.
term : A -> reified_args A B -> reified B.
const : A -> reified A.
bvar : A -> reified_args A B -> reified B.
nvar : A -> reified_args A B -> reified B.
lambda : (A -> reified B) -> reified (A -> B).

%end.

%extend refl.
isbvar : [A]A -> prop.
%end.

reify : [A]A -> reified A -> prop.
reify_args : [A B]args A B -> reified_args A B -> prop.
reify_var : [A]A -> reified A -> prop.

emptysubst : list dyn -> list dyn -> prop.
emptysubst [] [].
emptysubst (dyn (HD : A) :: TL) (dyn (HD' : A) :: TL') :- emptysubst TL TL'.

reify X (reified.unifvar I SubstR X) when refl.isunif(X) :-
  refl.decomposeunif X I SubstDyn,
  dyn.to_args SubstDyn Subst,
  reify_args Subst SubstR.

reify X (reified.term Head ArgsR)
    when refl.headargs X Head ArgsDyn, refl.isbaseterm X, 
         not(refl.isbvar Head), not(refl.isnvar Head) :-
  dyn.to_args ArgsDyn Args, reify_args Args ArgsR.

reify X (reified.const X) when refl.isconst X.

reify (X : A -> B) (reified.lambda X_R) when not(reify_var X _) :-
  (x:A -> refl.isbvar x -> reify_var x (reified.bvar x []) -> ([Body]
   reify (X x) Body, eq Body (X_R x))).

reify X Y when not(refl.isunif X), reify_var X Y.

reify X (reified.bvar Head ArgsR) when refl.headargs X Head ArgsDyn, refl.isbvar Head :-
  dyn.to_args ArgsDyn Args, reify_args Args ArgsR.

reify X (reified.nvar Head ArgsR) when refl.headargs X Head ArgsDyn, not(refl.isbvar Head), refl.isnvar Head :-
  dyn.to_args ArgsDyn Args, reify_args Args ArgsR.

reify_args [] [].
reify_args (HD :: TL) (HD_R :: TL_R) :- reify HD HD_R, reify_args TL TL_R.

reflect : [A]reified A -> A -> prop.
reflect : [A B]reified_args A B -> args A B -> prop.

reflect (reified.unifvar I SubstR X) Z :-
  reflect SubstR Subst, dyn.from_args Subst SubstDyn, refl.recomposeunif X SubstDyn Z.

reflect (reified.term Head ArgsR) Z :-
  reflect ArgsR Args, dyn.from_args Args ArgsDyn, refl.headargs Z Head ArgsDyn.

reflect (reified.const Const) Const.

reflect (reified.nvar Head ArgsR) Z :-
  reflect ArgsR Args, dyn.from_args Args ArgsDyn, refl.headargs Z Head ArgsDyn.

reflect (reified.bvar Head ArgsR) Z :-
  reflect ArgsR Args, dyn.from_args Args ArgsDyn, refl.headargs Z Head ArgsDyn.

reflect (reified.lambda X_R) X :-
  (x:A -> reflect (reified.bvar x []) x -> reflect (X_R x) (X x)).

reflect [] [].
reflect (HD_R :: TL_R) (HD :: TL) :- reflect HD_R HD, reflect TL_R TL.

eq_nounif : [A]A -> A -> prop.
(* TODO: something (other than the bvar situation) is introducing multiple cases into reify, figure it out. *)
eq_nounif A B :- once(reify A Areified), once(reify B Breified), eq Areified Breified.

%extend stdlib_tests.

reify : testsuite.

term : type.
unit : term.
app : term -> term -> term.
lam : (term -> term) -> term.
freevar : string -> term.

reify : [A]A -> reified A -> prop.
reify X Y :- once(.reify X Y).

testcase reify :- reify "lala" X, eq X (reified.const "lala").
testcase reify :- reify unit X, eq X (reified.term unit []).
testcase reify :- reify (app unit unit) X, eq X (reified.term app [reified.term unit [], reified.term unit []]).
testcase reify :- reify (fun (x: term) => "a") X, eq X (reified.lambda (fun x => reified.const "a")).
testcase reify :- reify (fun (x: term) => x) X, eq X (reified.lambda (fun x => reified.bvar x [])).
testcase reify :- (z:term -> (reify z (X z), eq (X z) (reified.nvar z []))).
testcase reify :- reify app X, eq X (reified.lambda (fun a => reified.lambda (fun b => reified.term app [reified.bvar a [], reified.bvar b []]))).
testcase reify :- reify X R, eq R (reified.unifvar I [] X).
testcase reify :- reify (X, X) R, eq R (reified.term tuple [reified.unifvar I1 [] X, reified.unifvar I2 [] X]), eq I1 I2.
testcase reify :- reify (X, Y) R, eq R (reified.term tuple [reified.unifvar I1 [] X, reified.unifvar I2 [] Y]), not(eq I1 I2).
testcase reify :- reify (fun (x:term->term) => x) R, eq R (reified.lambda (fun b => reified.bvar b [])).
testcase reify :- reify (fun (x:term) => E x) R, eq R (reified.lambda (fun x => reified.unifvar I [reified.bvar x []] (E x))).

(* TODO: testcases for reflect *)
(* TODO: testcases for reflect . reify *)

testcase reify :- reify lam X, reflect X Q, eq Q lam.

(* double reify and reflect *)
testcase reify :- eq X0 lam, reify X0 X1, reify X1 X2, reflect X2 X3, reflect X3 X4, eq X4 lam.
testcase reify :- (z:term -> ([X0 X1 X2 X3 X4](eq X0 (fun (w:term->term) => z), reify X0 X1, reify X1 X2, reflect X2 X3, reflect X3 X4, eq X4 X0))).
testcase reify :- (z:term -> ([X0 X1 X2 X3 X4](eq X0 (fun (w:term->term) => w), reify X0 X1, reify X1 X2, reflect X2 X3, reflect X3 X4, eq X4 X0))).
testcase reify :- (z:term -> ([X0 X1 X2 X3 X4](eq X0 (fun (w:term->term) => w z), reify X0 X1, reify X1 X2, reflect X2 X3, reflect X3 X4, eq X4 X0))).
testcase reify :- (z:(term -> term) -> ([X0 X1 X2 X3 X4](eq X0 (fun (w:(term->term)->term) => w z), reify X0 X1, reify X1 X2, reflect X2 X3, reflect X3 X4, eq X4 X0))).


testcase reify :-
  eq Term (fun z => app (lam (fun x => app E1 (E2 x))) (app z (freevar "test"))),
  eq Reified (fun z =>
             (reified.term app [
              reified.term lam [
                reified.lambda (fun x =>
                  reified.term app [
                    reified.unifvar Index1 [] E1,
                    reified.unifvar Index2 [reified.bvar x []] (E2 x)
                  ]
                )
              ],
              reified.term app [
                reified.nvar z [],
                reified.term freevar [reified.const "test"]
              ]
            ])),
  (z:term -> (reify (Term z) (R z),
              eq (R z) (Reified z),
              not(eq Index1 Index2),
              reflect (R z) (Term' z),
              eq_nounif (Term z) (Term' z),
              reify (Term' z) (R' z),
              eq_nounif (R z) (R' z))).

testcase reify :-
  eq Term (fun z => app (lam (fun x => app E1 (E2 x))) (app z (freevar "test"))),
  eq Reified (fun z =>
             (reified.term app [
              reified.term lam [
                reified.lambda (fun x =>
                  reified.term app [
                    reified.unifvar _ [] E1,
                    reified.unifvar _ [reified.bvar x []] (E2 x)
                  ]
                )
              ],
              reified.term app [
                reified.nvar z [],
                reified.term freevar [reified.const "test"]
              ]
            ])),
  (z:term -> (reflect (Reified z) (T z),
              eq_nounif (T z) (Term z),
              reify (T z) (Reified' z),
              eq (Reified' z) (Reified z))).

%end.



eqv_aux : [A]reified A -> reified A -> (prop -> prop) -> (prop -> prop) -> prop.
eqv_args : [A B]reified_args A B -> reified_args A B -> (prop -> prop) -> (prop -> prop) -> prop.
eqv_assigned : int -> prop.
eqv_unifvars : int -> int -> prop.

eqv_aux (reified.unifvar I1 Args1 _) (reified.unifvar I2 Args2 _) Ctx Ctx'
    when Ctx(eqv_unifvars I1 I2) :-
  eqv_args Args1 Args2 Ctx Ctx'.

eqv_aux (reified.unifvar I1 Args1 (_: A)) (reified.unifvar I2 Args2 (_: A)) Ctx Ctx''
    when Ctx( {prop| not(eqv_assigned I1), not(eqv_assigned I2) |} ) :-
   eq Ctx' (pfun k =>
     (eqv_assigned I1 -> eqv_assigned I2 ->
      eqv_unifvars I1 I2 -> eqv_unifvars I2 I1 ->
      Ctx k)),
   eqv_args Args1 Args2 Ctx' Ctx''.

eqv_aux (reified.term Head Args) (reified.term Head Args') Ctx Ctx' :-
  eqv_args Args Args' Ctx Ctx'.

eqv_aux (reified.bvar Head Args) (reified.bvar Head Args') Ctx Ctx' :-
  eqv_args Args Args' Ctx Ctx'.

eqv_aux (reified.nvar Head Args) (reified.nvar Head Args') Ctx Ctx' :-
  eqv_args Args Args' Ctx Ctx'.

eqv_aux (reified.const Const) (reified.const Const) Ctx Ctx.

eqv_aux (reified.lambda F) (reified.lambda F') Ctx Ctx' :-
  (x:A -> eqv_aux (F x) (F' x) Ctx Ctx').

eqv_args [] [] Ctx Ctx.
eqv_args (HD :: TL) (HD' :: TL') Ctx Ctx'' :-
  eqv_aux HD HD' Ctx Ctx', eqv_args TL TL' Ctx' Ctx''.

eqv (X: reified A) (Y: reified A) :-
  eqv_aux X Y (fun x => x) _.

unif_alpha_eqv : [A]A -> A -> prop.
unif_alpha_eqv X Y :- once(reify X XR), once(reify Y YR), eqv XR YR.


%extend stdlib_tests.
testcase reify :- unif_alpha_eqv (X: string) (Y: string).
testcase reify :- not(unif_alpha_eqv (dyn (X: string)) (dyn (Y: int))).
testcase reify :- unif_alpha_eqv (lam X) (lam Y).
testcase reify :- not(unif_alpha_eqv (app X Y) (app W W)).
%end.
