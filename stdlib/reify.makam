reified : type -> type.

args : type -> type -> type.
nil : args A A.
cons : A -> args B C -> args (A -> B) C.

%extend dyn.
to_args : [A B] list dyn -> args A B -> prop.
to_args [] [].
to_args (dyn HD :: TL) (HD :: TL') :- to_args TL TL'.

from_args : [A B] args A B -> list dyn -> prop.
from_args [] [].
from_args (HD :: TL) (dyn HD :: TL') :- from_args TL TL'.
%end.

reified_args : type -> type -> type.
nil : reified_args A A.
cons : reified A -> reified_args B C -> reified_args (A -> B) C.

%extend reified.

unifvar : int -> reified_args A B -> B -> reified B.
term : A -> reified_args A B -> reified B.
const : A -> reified A.
bvar : reified A -> reified A.
nvar : A -> reified_args A B -> reified B.
lambda : (A -> reified A -> reified B) -> reified (A -> B).

%end.

%extend refl.
isbvar : [A]A -> prop.
%end.

reify : [A]A -> reified A -> prop.
reify_args : [A B]args A B -> reified_args A B -> prop.
reify_var : [A]A -> reified A -> prop.

emptysubst : list dyn -> list dyn -> prop.
emptysubst [] [].
emptysubst (dyn (HD : A) :: TL) (dyn (HD' : A) :: TL') :- emptysubst TL TL'.

reify X (reified.unifvar I SubstR X) when refl.isunif(X) :-
  refl.decomposeunif X I SubstDyn,
  dyn.to_args SubstDyn Subst,
  reify_args Subst SubstR.

reify X (reified.term Head ArgsR)
    when refl.headargs X Head ArgsDyn, refl.isbaseterm X, 
         not(refl.isbvar Head), not(refl.isnvar Head) :-
  dyn.to_args ArgsDyn Args, reify_args Args ArgsR.

reify X (reified.const X) when refl.isconst X.

reify (X : A -> B) (reified.lambda X_R) :-
  (x:A -> y:(reified A) -> refl.isbvar x -> reify_var x y -> reify (X x) (X_R x y)).

reify X (reified.bvar Y) when not(refl.isunif X), reify_var X Y.

reify X (reified.nvar Head ArgsR) when refl.headargs X Head ArgsDyn, not(refl.isbvar Head), refl.isnvar Head :-
  dyn.to_args ArgsDyn Args, reify_args Args ArgsR.

reify_args [] [].
reify_args (HD :: TL) (HD_R :: TL_R) :- reify HD HD_R, reify_args TL TL_R.

reflect : [A]reified A -> A -> prop.
reflect : [A B]reified_args A B -> args A B -> prop.

reflect (reified.unifvar I SubstR X) Z :-
  reflect SubstR Subst, dyn.from_args Subst SubstDyn, refl.recomposeunif X SubstDyn Z.

reflect (reified.term Head ArgsR) Z :-
  reflect ArgsR Args, dyn.from_args Args ArgsDyn, refl.headargs Z Head ArgsDyn.

reflect (reified.const Const) Const.

reflect (reified.nvar Head ArgsR) Z :-
  reflect ArgsR Args, dyn.from_args Args ArgsDyn, refl.headargs Z Head ArgsDyn.

reflect (reified.lambda X_R) X :-
  (x:A -> y:(reified A) -> reflect (reified.bvar y) x -> reflect (X_R x y) (X x)).

reflect [] [].
reflect (HD_R :: TL_R) (HD :: TL) :- reflect HD_R HD, reflect TL_R TL.

reif_eq_nounif : [A]A -> A -> prop.
(* TODO: something is introducing multiple cases into reify, figure it out. *)
reif_eq_nounif A B :- once(reify A Areified), once(reify B Breified), eq Areified Breified.



%extend tests.

reify : testsuite.

term : type.
unit : term.
app : term -> term -> term.
lam : (term -> term) -> term.
freevar : string -> term.

reify : [A]A -> reified A -> prop.
reify X Y :- once(.reify X Y).

testcase reify :- reify "lala" (reified.const "lala").
testcase reify :- reify unit (reified.term unit []).
testcase reify :- reify (app unit unit) (reified.term app [reified.term unit [], reified.term unit []]).
testcase reify :- reify (fun (x: term) => "a") (reified.lambda (fun _ x => reified.const "a")).
testcase reify :- reify (fun (x: term) => x) (reified.lambda (fun _ x => reified.bvar x)).
testcase reify :- (z:term -> reify z (reified.nvar z [])).
testcase reify :- reify app (reified.lambda (fun _ a => reified.lambda (fun _ b => reified.term app [reified.bvar a, reified.bvar b]))).

(*
%debug+. %debugfull+.
reify (fun (helloooo:term -> term) => helloooo) Z ?
%debug-. %debugfull-.
*)

reify (fun (helloooo:term -> term) => helloooo) Z ?

testcase reify :-
  eq Term (fun z => app (lam (fun x => app E1 (E2 x))) (app z (freevar "test"))),
  eq Reified (fun z =>
             (reified.term app [
              reified.term lam [
                reified.lambda (fun xw x =>
                  reified.term app [
                    reified.unifvar Index1 [] E1,
                    reified.unifvar Index2 [reified.bvar x] (E2 xw)
                  ]
                )
              ],
              reified.term app [
                reified.nvar z [],
                reified.term freevar [reified.const "test"]
              ]
            ])),
  (z:term -> (reify (Term z) (R z),
              eq (R z) (Reified z),
              not(eq Index1 Index2),
              reflect (R z) (Term' z),
              eq_nounif (Term z) (Term' z),
              reif_eq_nounif (Term z) (Term' z),
              reify (Term' z) (R' z),
              reify (R z) (RR z),
              eq_nounif (R z) (R' z),
              reif_eq_nounif (R z) (R' z))).

testcase reify :-
  eq Term (fun z => app (lam (fun x => app E1 (E2 x))) (app z (freevar "test"))),
  eq Reified (fun z =>
             (reified.term app [
              reified.term lam [
                reified.lambda (fun xw x =>
                  reified.term app [
                    reified.unifvar _ [] E1,
                    reified.unifvar _ [reified.bvar x] (E2 xw)
                  ]
                )
              ],
              reified.term app [
                reified.nvar z [],
                reified.term freevar [reified.const "test"]
              ]
            ])),
  (z:term -> (reflect (Reified z) (T z),
              eq_nounif (T z) (Term z),
              reify (T z) (Reified' z),
              eq (Reified' z) (Reified z))).

%end.

run_tests X ?

(*
(w:string -> (reify (fun (z: string) => w) (X w), reify (X w) (Z w))) ?

*)