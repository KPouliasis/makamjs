structural : (A -> A -> prop) -> B -> B -> prop.

(* defer if both input and output are uninstantiated metavariables *)
structural Rec (X : A) (Y : A) when refl.isunif X, refl.isunif Y <-
  guardmany (X, Y) (dyn.call Rec X Y).

(* deal with built-in types *)
structural Rec X X when refl.isconst X.

(* deal with functions *)
structural Rec (X : A -> B) (Y : A -> B) <-
  (x:A -> dyn.call Rec (X x) (Y x)).

(* the essence: forward and backward destructuring *)
structural Rec X Y when refl.isbaseterm X <-
  refl.headargs X Hd Args,
  dyn.map Rec Args Args',
  refl.headargs Y Hd Args'.

structural Rec X Y when refl.isunif X, refl.isbaseterm Y <-
  refl.headargs Y Hd Args',
  dyn.map Rec Args Args',
  refl.headargs X Hd Args.
