%extend dyn.
(* A version of `eq` that delays type unification of the terms until runtime *)
eq : A -> B -> prop.
eq X X.

(* Similarly, a dynamically-typed version of application. *)
apply : A -> B -> C -> prop.
apply F X (F X).

(* Magic: fake rank-N polymorphism by duplicating all heads found, therefore
   generating new polymorphic variables for them. *)
poly : A -> B -> prop.
polymap : list dyn -> list dyn -> prop.

%extend refl.
isnvar : A -> prop.
(isnvar X) when newnmeta (fun x => eq x X).
%end.

poly C C when refl.isconst C.
poly X X when refl.isunif X.
poly F F' when refl.isfun F <- (x:A -> x':A' -> poly x x' -> poly (F x) (F' x')).
poly E E' when refl.isbaseterm E <-
  refl.headargs E HD ARGS,
  refl.duphead HD HD',
  polymap ARGS ARGS',
  refl.headargs E' HD' ARGS'.

polymap [] [].
polymap (dyn HD :: TL) (dyn HD' :: TL') <- poly HD HD', polymap TL TL'.

dynprop : (A -> prop) -> dyn -> prop.
dynprop P (dyn X) <- poly P P', P' X.

dynprop : (A -> B -> prop) -> dyn -> dyn -> prop.
dynprop P (dyn X) (dyn Y) <- poly P P', P' X Y.

iter : (A -> prop) -> list dyn -> prop.
iter P L <- map (dynprop P) L.

map : (A -> B -> prop) -> list dyn -> list dyn -> prop.
map P L L' <- map (dynprop P) L L'.

%end.

(* Apply many arguments *)
apply_many : A -> list dyn -> B -> prop.
apply_many X nil X.
apply_many (X : A -> B) (dyn HD :: TL) Res <- dyn.apply X HD X', apply_many X' TL Res.

(* Apply all arguments -- when the argument list is not specified,
   this will repeatedly apply arguments, generating new unification
   variables, for the full arity of the functional argument. *)
apply_all : A -> list dyn -> B -> prop.
apply_all (X : A -> B) (dyn HD :: TL) Res <- dyn.apply X HD X', apply_all X' TL Res.
(apply_all X nil X) when not(typ.eq X (_ : A -> B)).
