%extend dyn.
(* A version of `eq` that delays type unification of the terms until runtime *)
eq : A -> B -> prop.
eq X X.

(* Similarly, a dynamically-typed version of application. *)
apply : A -> B -> C -> prop.
apply F X (F X).

(* Magic: fake rank-N polymorphism by duplicating all heads found, therefore
   generating new polymorphic variables for them. *)
poly : A -> B -> prop.
map_poly : list dyn -> list dyn -> prop.

poly C C when refl.isconst C.
poly X X when refl.isunif X.
poly F F' when refl.isfun F <- (x:A -> x':A' -> poly x x' -> poly (F x) (F' x')).
poly E E' when refl.isbaseterm E, refl.isnvar E <-
  refl.headargs E HD ARGS,
  map_poly ARGS ARGS',
  refl.headargs E' HD ARGS'.
poly E E' when refl.isbaseterm E, refl.isfvar E <-
  refl.headargs E HD ARGS,
  refl.duphead HD HD',
  map_poly ARGS ARGS',
  refl.headargs E' HD' ARGS'.

map_poly [] [].
map_poly (dyn HD :: TL) (dyn HD' :: TL') <- poly HD HD', map_poly TL TL'.

polycall : (A -> prop) -> dyn -> prop.
polycall P (dyn X) <- poly P P', P' X.

polycall : (A -> B -> prop) -> dyn -> dyn -> prop.
polycall P (dyn X) (dyn Y) <- poly P P', P' X Y.

polyiter : (A -> prop) -> list dyn -> prop.
polyiter P L <- map (polycall P) L.

polymap : (A -> B -> prop) -> list dyn -> list dyn -> prop.
polymap P L L' <- map (polycall P) L L'.

%end.

(* Apply many arguments *)
apply_many : A -> list dyn -> B -> prop.
apply_many X nil X.
apply_many (X : A -> B) (dyn HD :: TL) Res <- dyn.apply X HD X', apply_many X' TL Res.

(* Apply all arguments -- when the argument list is not specified,
   this will repeatedly apply arguments, generating new unification
   variables, for the full arity of the functional argument. *)
apply_all : A -> list dyn -> B -> prop.
apply_all (X : A -> B) (dyn HD :: TL) Res <- dyn.apply X HD X', apply_all X' TL Res.
(apply_all X nil X) when not(typ.eq X (_ : A -> B)).
